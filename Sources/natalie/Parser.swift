//
//  Parser.swift
//  Natalie
//
//  Created by Marcin Krzyzanowski on 07/08/16.
//  Copyright Â© 2016 Marcin Krzyzanowski. All rights reserved.
//

import Foundation

struct Parser {
    
    let storyboards: [StoryboardFile]
    init(storyboards: [StoryboardFile]) {
        self.storyboards = storyboards
    }

    func process(os: OS) -> String {
        var output = String()

        output += "//"
        output += "// Autogenerated by Natalie - Storyboard Generator Script."
        output += "// http://blog.krzyzanowskim.com"
        output += "//"
        output += ""
        output += "import \(os.framework)"
        let modules = storyboards.flatMap{ $0.storyboard.customModules }
        for module in Set<String>(modules) {
            output += "import \(module)"
        }
        output += ""

        output += "//MARK: - Storyboards"

        output += ""
        output += "extension \(os.storyboardType) {"
        for (signatureType, returnType) in os.storyboardInstantiationInfo {
            output += "    func instantiateViewController<T: \(returnType) where T: IdentifiableProtocol>(type: T.Type) -> T? {"
            output += "        let instance = type.init()"
            output += "        if let identifier = instance.storyboardIdentifier {"
            output += "            return self.instantiate\(signatureType)WithIdentifier(identifier) as? T"
            output += "        }"
            output += "        return nil"
            output += "    }"
            output += ""
        }
        output += "}"

        output += ""
        output += "protocol Storyboard {"
        output += "    static var storyboard: \(os.storyboardType) { get }"
        output += "    static var identifier: String { get }"
        output += "}"
        output += ""

        output += "struct Storyboards {"
        for file in storyboards {
            output += file.storyboard.processStoryboard(storyboardName: file.storyboardName, os: os)
        }
        output += "}"
        output += ""

        output += "//MARK: - ReusableKind"
        output += "enum ReusableKind: String, CustomStringConvertible {"
        output += "    case TableViewCell = \"tableViewCell\""
        output += "    case CollectionViewCell = \"collectionViewCell\""
        output += ""
        output += "    var description: String { return self.rawValue }"
        output += "}"
        output += ""

        output += "//MARK: - SegueKind"
        output += "enum SegueKind: String, CustomStringConvertible {    "
        output += "    case Relationship = \"relationship\" "
        output += "    case Show = \"show\"                 "
        output += "    case Presentation = \"presentation\" "
        output += "    case Embed = \"embed\"               "
        output += "    case Unwind = \"unwind\"             "
        output += "    case Push = \"push\"                 "
        output += "    case Modal = \"modal\"               "
        output += "    case Popover = \"popover\"           "
        output += "    case Replace = \"replace\"           "
        output += "    case Custom = \"custom\"             "
        output += ""
        output += "    var description: String { return self.rawValue } "
        output += "}"
        output += ""
        output += "//MARK: - IdentifiableProtocol"
        output += ""
        output += "public protocol IdentifiableProtocol: Equatable {"
        output += "    var storyboardIdentifier: String? { get }"
        output += "}"
        output += ""
        output += "//MARK: - SegueProtocol"
        output += ""
        output += "public protocol SegueProtocol {"
        output += "    var identifier: String? { get }"
        output += "}"
        output += ""

        output += "public func ==<T: SegueProtocol, U: SegueProtocol>(lhs: T, rhs: U) -> Bool {"
        output += "    return lhs.identifier == rhs.identifier"
        output += "}"
        output += ""
        output += "public func ~=<T: SegueProtocol, U: SegueProtocol>(lhs: T, rhs: U) -> Bool {"
        output += "    return lhs.identifier == rhs.identifier"
        output += "}"
        output += ""
        output += "public func ==<T: SegueProtocol>(lhs: T, rhs: String) -> Bool {"
        output += "    return lhs.identifier == rhs"
        output += "}"
        output += ""
        output += "public func ~=<T: SegueProtocol>(lhs: T, rhs: String) -> Bool {"
        output += "    return lhs.identifier == rhs"
        output += "}"
        output += ""
        output += "public func ==<T: SegueProtocol>(lhs: String, rhs: T) -> Bool {"
        output += "    return lhs == rhs.identifier"
        output += "}"
        output += ""
        output += "public func ~=<T: SegueProtocol>(lhs: String, rhs: T) -> Bool {"
        output += "    return lhs == rhs.identifier"
        output += "}"
        output += ""

        output += "//MARK: - ReusableViewProtocol"
        output += "public protocol ReusableViewProtocol: IdentifiableProtocol {"
        output += "    var viewType: \(os.viewType).Type? { get }"
        output += "}"
        output += ""

        output += "public func ==<T: ReusableViewProtocol, U: ReusableViewProtocol>(lhs: T, rhs: U) -> Bool {"
        output += "    return lhs.storyboardIdentifier == rhs.storyboardIdentifier"
        output += "}"
        output += ""

        output += "//MARK: - Protocol Implementation"
        output += "extension \(os.storyboardSegueType): SegueProtocol {"
        output += "}"
        output += ""

        if let reusableViews = os.resuableViews {
            for reusableView in reusableViews {
                output += "extension \(reusableView): ReusableViewProtocol {"
                output += "    public var viewType: UIView.Type? { return self.dynamicType }"
                output += "    public var storyboardIdentifier: String? { return self.reuseIdentifier }"
                output += "}"
                output += ""
            }
        }

        for controllerType in os.storyboardControllerTypes {
            output += "//MARK: - \(controllerType) extension"
            output += "extension \(controllerType) {"
            output += "    func performSegue<T: SegueProtocol>(segue: T, sender: AnyObject?) {"
            output += "        if let identifier = segue.identifier {"
            output += "            performSegueWithIdentifier(identifier, sender: sender)"
            output += "        }"
            output += "    }"
            output += ""
            output += "    func performSegue<T: SegueProtocol>(segue: T) {"
            output += "        performSegue(segue, sender: nil)"
            output += "    }"
            output += "}"
            output += ""
        }

        if os == OS.iOS {
            output += "//MARK: - UICollectionView"
            output += ""
            output += "extension UICollectionView {"
            output += ""
            output += "    func dequeueReusableCell<T: ReusableViewProtocol>(reusable: T, forIndexPath: NSIndexPath!) -> UICollectionViewCell? {"
            output += "        if let identifier = reusable.storyboardIdentifier {"
            output += "            return dequeueReusableCellWithReuseIdentifier(identifier, forIndexPath: forIndexPath)"
            output += "        }"
            output += "        return nil"
            output += "    }"
            output += ""
            output += "    func registerReusableCell<T: ReusableViewProtocol>(reusable: T) {"
            output += "        if let type = reusable.viewType, identifier = reusable.storyboardIdentifier {"
            output += "            registerClass(type, forCellWithReuseIdentifier: identifier)"
            output += "        }"
            output += "    }"
            output += ""
            output += "    func dequeueReusableSupplementaryViewOfKind<T: ReusableViewProtocol>(elementKind: String, withReusable reusable: T, forIndexPath: NSIndexPath!) -> UICollectionReusableView? {"
            output += "        if let identifier = reusable.storyboardIdentifier {"
            output += "            return dequeueReusableSupplementaryViewOfKind(elementKind, withReuseIdentifier: identifier, forIndexPath: forIndexPath)"
            output += "        }"
            output += "        return nil"
            output += "    }"
            output += ""
            output += "    func registerReusable<T: ReusableViewProtocol>(reusable: T, forSupplementaryViewOfKind elementKind: String) {"
            output += "        if let type = reusable.viewType, identifier = reusable.storyboardIdentifier {"
            output += "            registerClass(type, forSupplementaryViewOfKind: elementKind, withReuseIdentifier: identifier)"
            output += "        }"
            output += "    }"
            output += "}"

            output += "//MARK: - UITableView"
            output += ""
            output += "extension UITableView {"
            output += ""
            output += "    func dequeueReusableCell<T: ReusableViewProtocol>(reusable: T, forIndexPath: NSIndexPath!) -> UITableViewCell? {"
            output += "        if let identifier = reusable.storyboardIdentifier {"
            output += "            return dequeueReusableCellWithIdentifier(identifier, forIndexPath: forIndexPath)"
            output += "        }"
            output += "        return nil"
            output += "    }"
            output += ""
            output += "    func registerReusableCell<T: ReusableViewProtocol>(reusable: T) {"
            output += "        if let type = reusable.viewType, identifier = reusable.storyboardIdentifier {"
            output += "            registerClass(type, forCellReuseIdentifier: identifier)"
            output += "        }"
            output += "    }"
            output += ""
            output += "    func dequeueReusableHeaderFooter<T: ReusableViewProtocol>(reusable: T) -> UITableViewHeaderFooterView? {"
            output += "        if let identifier = reusable.storyboardIdentifier {"
            output += "            return dequeueReusableHeaderFooterViewWithIdentifier(identifier)"
            output += "        }"
            output += "        return nil"
            output += "    }"
            output += ""
            output += "    func registerReusableHeaderFooter<T: ReusableViewProtocol>(reusable: T) {"
            output += "        if let type = reusable.viewType, identifier = reusable.storyboardIdentifier {"
            output += "             registerClass(type, forHeaderFooterViewReuseIdentifier: identifier)"
            output += "        }"
            output += "    }"
            output += "}"
            output += ""
        }

        for file in storyboards {
            output += file.storyboard.processViewControllers()
        }

        return output
    }
}
